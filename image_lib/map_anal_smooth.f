C*******************************************************************************
C
C  SMOOTH
C  ------
C
C  Performs convolution of a map with a north-south elliptical gaussian
C  beam.
C
C  Scaling:  The program assumes that the input map was made with a gaussian
C  beam (e.g. generated by CLEAN) and that it is therefore possible to scale
C  the output map in flux density per beam area.  This means that maps with
C  different initial beamwidths can be convolved to the same resolution and
C  the flux scales will be correct for spectral index comparison (for instance).
C  The output scale is also meaningful when the program is used to convolve a
C  Maximum Entropy map, or any other map scaled in flux density per pixel.
C  In these cases, the input beamwidth should be set to zero.
C
C  Accuracy:  The program takes into account the final pixel size when working
C  out the area of the beam:  hence there is no particular inaccuracy involved
C  in working with beams whose size is comparable to the pixel size (or even
C  zero!).  In practice the flux of an unresolved gaussian point source is
C  found to be constant to about 0.3 %.
C
C  Edges:  A general problem for convolution programs is the treatment at
C  the edge of the map, where data runs out under up to half the convolving
C  beam.  Two cases are of interest:
C
C  1)  If the required area of the output map is sufficiently smaller than
C      that covered by the input map, the most self-consistent course is
C      to use the real data outside the edge of the final map.  This can
C      be done by allowing the U,V range of the input area to default to
C      to the full input map.
C
C  2)  If the outer edges of the input map are contaminated, e.g. by
C      grating rings or by being outside the CLEAN window, they can be
C      rejected by restricting the input U,V range.  Fake data is provided
C      outside the input window either by repeating the data values at the
C      edge as necessary, or by setting extra points to the map zero level.
C
C  In practice, there should be little difference between these approaches.
C
C
C  Original IBM program by J P Leahy .................. October 1984
C  ND-500 implementation by DJT ........................... May 1987
C  ANMAP routine by PA ................................. August 1987
C  ANMAP improvements to error handling by PA ........ November 1987
C  ANMAP io_attn handling by PA ......................... November 1987
C  Map centre position DJT/PA ........................ December 1987
C  ANMAP new stack library .............................. April 1988
C  ANMAP new MAPCAT-LIB library PA ..................... August 1990
C
C  This program uses routines from the MAPLIB and IOLIB libraries.
C  DATA must be  on the ANMAP stack, passed in map_array(*).
C
C*******************************************************************************
C
       SUBROUTINE DO_SMOOTH(MAP_ARRAY,STATUS)
C      -------------------------------------
C
C Run the smooth utility
C
       REAL*4     MAP_ARRAY(*)
C
       CHARACTER  STRING*40
       INTEGER    IOUT, L, chr_lenb, STATUS
       INTEGER    IMAPI, IMAPO, IP_MAPI, IP_MAPO
       LOGICAL    INTER
C
       INTEGER    MSIZE
       PARAMETER (MSIZE=512)
       REAL*8     HPBWI(2), HPBWO(2), UAREA, VAREA, XMCO, YMCO
       REAL*4     UBEAM(101), VBEAM(101)
       INTEGER    IUVI(4), IUVO(4), NSAMP(2)
       INTEGER    MAXBU, MAXBV, NX, NY, ICODE, IEDGE
C
       COMMON /CONTROL/ HPBWI, HPBWO, IUVI, IUVO, NSAMP, IEDGE, INTER
       COMMON /BEAMS/ UBEAM, VBEAM, UAREA, VAREA, MAXBU, MAXBV
C
       include '/mrao/include/maplib_redtape.inc'
C
C
C  Initialise the I/O system
C
       IF (STATUS.NE.0) RETURN
       INTER=.TRUE.
       CALL io_enqout(IOUT)
C
C  Get the input and output maps
C
       CALL MAP_GETMAP('Map : ','Default-Map','READ',
     *                  IMAPI,STATUS)
       CALL MAP_ALLOC_IN(IMAPI,'DIRECT',MAP_ARRAY,IP_MAPI,STATUS)
       CALL MAP_ALLOC_OUT(0,0,'DIRECT',IMAPO,IP_MAPO,STATUS)
C
C  Get the control data
C
       CALL GETPARS(STATUS)
       IF (STATUS.NE.0) THEN

C .. output error messages and close all maps
         CALL cmd_ERR(STATUS,'SMOOTH-MAP',' ')
         CALL map_end_alloc(IMAPI,MAP_ARRAY,STATUS)
         CALL map_end_alloc(IMAPO,MAP_ARRAY,STATUS)
         RETURN
       END IF
C
C  Make the convolving beams
C
       CALL GMAKE(HPBWI(1),HPBWO(1),USAMP,UBEAM,UAREA,MAXBU,STATUS)
       CALL GMAKE(HPBWI(2),HPBWO(2),VSAMP,VBEAM,VAREA,MAXBV,STATUS)
C
C  Perform the convolution
C
       CALL SMOOTH(MAP_ARRAY(IP_MAPI),IUVI,IUVO,NSAMP,IEDGE,
     :             MAP_ARRAY(IP_MAPO),NX,NY,STATUS)
C
C  Work out the final output beam area
C
       IF (STATUS.NE.0) THEN

C .. output error messages and close all maps
         CALL cmd_ERR(STATUS,'SMOOTH-MAP',' ')
         CALL map_end_alloc(IMAPI,MAP_ARRAY,STATUS)
         CALL map_end_alloc(IMAPO,MAP_ARRAY,STATUS)
         RETURN
       END IF
       HPFBWU=HPBWO(1)
       HPFBWV=HPBWO(2)
       USAMP=NSAMP(1)*USAMP
       VSAMP=NSAMP(2)*VSAMP
       CALL GMAKE(0.D0,HPBWO(1),USAMP,UBEAM,UAREA,MAXBU,STATUS)
       CALL GMAKE(0.D0,HPBWO(2),VSAMP,VBEAM,VAREA,MAXBV,STATUS)
       if (status.ne.0) then
         status = 0
         FLXNRM=1.D0/(UAREA*VAREA)
       else
         flxnrm = 1.0
       endif
C
C  Work out map centre position with output map
C
       XMCO=(XMC-(1-IUMAP1))/NSAMP(1) + (1-IUVO(1))
       YMCO=(YMC-(1+IVMAP1))/NSAMP(2) + (1+IUVO(3))
C
C  Adjust redtape for the output map
C
       ICODE=ISWD
       CALL STREDT(IUVO,ICODE,STATUS)
       CALL ADREDT('HISTORY','SMOOTH',STATUS)
       WRITE(STRING,'(2X,F6.2)')HPFBWU
       CALL chr_chljus(STRING(3:),L)
       WRITE(STRING(L+3:),'(A,F6.2)')' x ',HPFBWV
       CALL chr_chljus(STRING(L+6:),L)
       STRING(chr_lenb(STRING)+1:)=' arcsec resolution'
       CALL ADREDT('TITLE',STRING,STATUS)
C
C  Set up map centre position
C
       XMC = XMCO
       YMC = YMCO
C
C  End output map
C
       CALL map_end_alloc(IMAPO,MAP_ARRAY,STATUS)
       CALL map_end_alloc(IMAPI,MAP_ARRAY,STATUS)
       CALL cmd_ERR(STATUS,'SMOOTH-MAP','Failed')

       END
C
C
C+
       SUBROUTINE GETPARS (STATUS)
C      ---------------------------
C
C  Reads control data for the SMOOTH program.
C
C  Reads and checks the following control parameters:
C
C      - u,v window on input map
C      - u,v sampling factors for output map
C      - u,v range to be written to the output map
C      - HPFW beamwidths for input map, in u and v
C      - HPFW beamwidths for output map, in u and v
C      - treatment of input map edge during convolution
C
C  The STATUS value should be zero on entry.
C
C-
       CHARACTER DEFAULT*16
       REAL*8   HPBWI(2), HPBWO(2), TEMP(2)
       INTEGER  IUVI(4), IUVO(4), NSAMP(2), IEDGE
       INTEGER  IOUT, STATUS
       LOGICAL  INTER, io_yesno
C
       COMMON /CONTROL/ HPBWI, HPBWO, IUVI, IUVO, NSAMP, IEDGE, INTER
C
       include '/mrao/include/maplib_redtape.inc'
C
C
       CALL io_enqout(IOUT)
C
C  Set up initial defaults
C
       IF (STATUS.NE.0) RETURN
       NSAMP(1)=1
       NSAMP(2)=1
       IUVI(1)=IUMAP1
       IUVI(2)=IUMAP2
       IUVI(3)=IVMAP1
       IUVI(4)=IVMAP2
       HPBWI(1)=HPFBWU
       HPBWI(2)=HPFBWV
       HPBWO(1)=HPBWI(1)
       HPBWO(2)=HPBWI(2)
C
C  Get u,v window on input map, default is whole map
C
       CALL PLOT_GETUV('UV window on input map  :','*',IUVI,STATUS)
       IF (STATUS.NE.0) RETURN
C
C  Get u,v sampling for output map, default is same as input map
C
       WRITE(DEFAULT,'(I2,'','',I2)')NSAMP
       CALL io_getni('Output map sampling (x input sampling) :',
     :                                  DEFAULT,NSAMP,2,STATUS)
       IF (STATUS.NE.0) RETURN
C
C  Get u,v range on output map, default corresponds to full input range
C
       IUVO(1)=IUVI(1)/NSAMP(1)
       IUVO(2)=IUVI(2)/NSAMP(1)
       IUVO(3)=IUVI(3)/NSAMP(2)
       IUVO(4)=IUVI(4)/NSAMP(2)
       IF (IUVO(1)*NSAMP(1).LT.IUVI(1)) IUVO(1)=IUVO(1)+1
       IF (IUVO(2)*NSAMP(1).GT.IUVI(2)) IUVO(2)=IUVO(2)-1
       IF (IUVO(3)*NSAMP(2).GT.IUVI(3)) IUVO(3)=IUVO(3)-1
       IF (IUVO(4)*NSAMP(2).LT.IUVI(4)) IUVO(4)=IUVO(4)+1
       CALL PLOT_GETUV('UV-range on output map  :','*',IUVO,STATUS)
       IF (STATUS.NE.0) RETURN
       IF (IUVO(1)*NSAMP(1).LT.IUVI(1) .OR.
     :     IUVO(2)*NSAMP(1).GT.IUVI(2) .OR.
     :     IUVO(3)*NSAMP(2).GT.IUVI(3) .OR.
     :     IUVO(4)*NSAMP(2).LT.IUVI(4)) THEN
         WRITE(IOUT,*)
     :   '*** requested output map region lies outside input region'
         STATUS = -1
         RETURN
       ENDIF
C
C  Get beamwidths for input and output maps
C
       TEMP(1)=HPBWI(1)
       TEMP(2)=HPBWI(2)
       WRITE(DEFAULT,'(2F7.2)')HPBWI
       CALL GETBW('HPFW beamwidths for input map  :',DEFAULT,
     :                                               HPBWI,STATUS)
       IF (HPBWI(1).NE.TEMP(1) .OR. HPBWI(2).NE.TEMP(2)) THEN
         HPBWO(1)=HPBWI(1)
         HPBWO(2)=HPBWI(2)
       ENDIF
       WRITE(DEFAULT,'(2F7.2)')HPBWO
       CALL GETBW('HPFW beamwidths for output map :',DEFAULT,
     :                                               HPBWO,STATUS)
C
C  Get control for treatment of map edge during convolution
C
       IF (STATUS.EQ.0) THEN
         IF (io_yesno(
     :   'Do you want to use repeated data values at the map edge : ',
     :   'yes',STATUS)) THEN
           IEDGE=1
         ELSE
           WRITE(IOUT,*)
     :     '.. values bordering the input window will be set to zero'
           IEDGE=2
         ENDIF
       ENDIF
C
C
       END
C
C
C+
       SUBROUTINE GMAKE (XIN, XOUT, CELL, BEAM, AREA, MAXPIX, STATUS)
C      --------------------------------------------------------------
C
C  Generates a 1-D gaussian array for use as a convolving function.
C
C  Parameters:
C      XIN       real*8      HPBW of input map (arcsec)
C      XOUT      real*8      HPBW of output map (arcsec)
C      CELL      real*8      grid cell size (arcsec)
C      BEAM      real*4      the output array containing the convolving
C                            beam from centre to edge
C      AREA      real*8      area of the convolving beam
C      MAXPIX    integer     no.of gridpoints from centre to edge of
C                            the convolving beam
C      STATUS    integer     status value
C
C  Given the half-power beamwidths of input and output gaussian beams, the
C  routine provides an appropriate scaled convolving function, for use on
C  the input data array.  A zero input beamwidth will generate the output
C  gaussian beam (and its area, for flux normalisation calculations).
C
C  Adapted from the original version by J P Leahy
C
C-
       REAL*8    XIN, XOUT, CELL, AREA, AREAO, AREACB
       REAL*8    SIGIN, SIGOUT, SIGCON, PEAK
       REAL*4    BEAM(101), BEAMI(-500:500)
       INTEGER   MAXIN, MAXOUT, MAXPIX
       INTEGER   I, J, STATUS
C
C
       IF (STATUS.NE.0) RETURN
C
C  SIGCON is 2 * variance of the convolving beam (gridpoints)
C
       SIGIN=XIN**2/(4*LOG(2.D0)*CELL**2)
       SIGOUT=XOUT**2/(4*LOG(2.D0)*CELL**2)
       SIGCON=SIGOUT-SIGIN
       IF (SIGCON.LT.0.D0) THEN
         WRITE(*,*)'*** final beam smaller than initial beam'
         STATUS=-1
         RETURN
       ENDIF
C
C  MAXPIX is the point where BEAM becomes small (<exp(-8))
C
       MAXIN=IDINT(4.D0*DSQRT(SIGIN/2.D0))
       MAXOUT=IDINT(4.D0*DSQRT(SIGOUT/2.D0))
       MAXPIX=IDINT(4.D0*DSQRT(SIGCON/2.D0))
       IF (MAXPIX.GT.100) THEN
         WRITE(*,*)'*** beam too big, use smaller oversampling',
     *             '  MAXPIX = ',maxpix,sigin,sigout,sigcon
         STATUS=-1
         RETURN
       ENDIF
C
C  Construct convolving beam
C
       AREA=1.D0
       BEAM(1)=1.0
       IF (MAXPIX.GT.0) THEN
         DO I=1,MAXPIX
           BEAM(I+1)=DEXP(-(I**2/SIGCON))
           AREA=AREA+2*BEAM(I+1)
         ENDDO
       ENDIF
C
C  Work out scaling factor for convolving beam
C
       IF (MAXOUT+MAXPIX.GT.100) THEN
         PEAK=(XOUT/XIN)/AREA
       ELSE
C
C    AREAO is the area of the output beam
C
         AREAO=1.D0
         IF (MAXOUT.GT.0) THEN
           DO I=1,MAXOUT
             AREAO=AREAO+2*DEXP(-(I**2/SIGOUT))
           ENDDO
         ENDIF
C
C    BEAMI is the input beam
C
         BEAMI(0)=1.0
         IF (MAXIN.GT.0) THEN
           DO I=1,MAXIN
             BEAMI(I)=DEXP(-(I**2/SIGIN))
             BEAMI(-I)=BEAMI(I)
           ENDDO
         ENDIF
         DO I=MAXIN+1,MAXOUT+MAXPIX
           BEAMI(I)=0.0
           BEAMI(-I)=0.0
         ENDDO
C
C    AREACB is the area of the input beam convolved with the
C    unscaled convolving beam
C
         AREACB=0.D0
         DO I=-MAXOUT,MAXOUT
           AREACB=AREACB+BEAMI(I)*BEAM(1)
           DO J=1,MAXPIX
             AREACB=AREACB+(BEAMI(I-J)+BEAMI(I+J))*BEAM(J+1)
           ENDDO
         ENDDO
C
         PEAK=AREAO/AREACB
C
       ENDIF
C
       BEAM(1)=PEAK
       DO I=1,MAXPIX
         BEAM(I+1)=PEAK*BEAM(I+1)
       ENDDO
       AREA=PEAK*AREA
C
       END
C
C
C
C
C+
       SUBROUTINE SMOOTH (DATA1, IUVI, IUVO, NSAMP, IEDGE, DATA2,
     :                                             NX, NY, STATUS)
C      -----------------------------------------------------------
C
C  Performs 2-d convolution of map data with gaussian beam.
C
C  Given:
C      DATA1     real*4()    input map data
C      IUVI      integer(4)  U,V window on input map
C      IUVO      integer(4)  U,V range on output map
C      NSAMP     integer(2)  U,V sampling factors
C      IEDGE     integer     control for treatment of map edge
C
C  Returned:
C      DATA2     real*4()    output map data
C      NX        integer     output row length
C      NY        integer     number of rows in output data
C      STATUS    integer     status value
C
C  Convolves the specified U,V window of the map data held by rows
C  in array DATA1, using an elliptical gaussian beam.  NSAMP controls
C  U,V sampling of the input data, and IEDGE the treatment of data at
C  the edge of the input window (if IEDGE=1, repeated data values are
C  used to perform the convolution;  if IEDGE=2, values outside the
C  window are set to zero).
C
C  The convolving beam is held as two symmetric 1-d gaussian arrays
C  in COMMON /BEAMS/.
C
C  The STATUS value should be zero on entry. Attention handling looks
C  for the ESC character and terminates routine with STATUS=USR_BREAK
C
C  (DJT, 20 May 87)
C
C-
       REAL*4   DATA1(1), DATA2(1), DATA(1024)
       INTEGER  IUVI(4), IUVO(4), NSAMP(2), IEDGE, NX, NY, STATUS
       INTEGER  IU, IV, IU1, IU2, IV1, IV2, NU, NV
       INTEGER  IX, IX1, IX2
C
       REAL*4   UBEAM(101), VBEAM(101)
       REAL*8   UAREA, VAREA
       INTEGER  MAXBU, MAXBV
       LOGICAL  io_attn
C
       COMMON /BEAMS/ UBEAM, VBEAM, UAREA, VAREA, MAXBU, MAXBV
C
       include '/mrao/include/maplib_errors.inc'
       include '/mrao/include/maplib_redtape.inc'
C
C Attention handling of ESCAPE is installed, termination of routine
C if ESC is pressed.
C
       NX=0
       NY=0
C
       IF (STATUS.EQ.0) THEN
C
C    Convolve rows : move each row in turn to the DATA buffer, expanding
C    if necessary beyond the input window.  Convolution is then performed
C    into successive rows of array DATA2.
C
         IU1=IUVO(1)*NSAMP(1)-MAXBU
         IU2=IUVO(2)*NSAMP(1)+MAXBU
         IV1=MIN0(IUVI(3),IUVO(3)*NSAMP(2)+MAXBV)
         IV2=MAX0(IUVI(4),IUVO(4)*NSAMP(2)-MAXBV)
         NU=IU2-IU1+1
C
         IX2=1
         DO IV=IV1,IV2,-1
           IF (io_attn(STATUS)) GOTO 1000
           IX=1
           IX1=(IVMAP1-IV)*IXMAX+(IUVI(1)-IUMAP1)+1
           IF (IU1.GT.IUVI(1)) IX1=IX1+IU1-IUVI(1)
           DO IU=IU1,IU2
             DATA(IX)=DATA1(IX1)
             IF (IU.LT.IUVI(1) .OR. IU.GT.IUVI(2)) THEN
               IF (IEDGE.EQ.2) DATA(IX)=0.0
             ELSEIF (IU.LT.IUVI(2)) THEN
               IX1=IX1+1
             ENDIF
             IX=IX+1
           ENDDO
           CALL CNVROW(DATA,NU,NSAMP(1),UBEAM,MAXBU,DATA2(IX2),NX,1)
           IX2=IX2+NX
         ENDDO
C
C    Convolve columns : move each column of convolved rows in turn to
C    the DATA buffer, expanding if necessary beyond the input window.
C    The convolution is then performed back into successive columns of
C    array DATA2.
C
         IV1=IUVO(3)*NSAMP(2)+MAXBV
         IV2=IUVO(4)*NSAMP(2)-MAXBV
         NV=IV1-IV2+1
C
         DO IU=1,NX
           IF (io_attn(STATUS)) GOTO 1000
           IX=1
           IX1=IU
           IX2=IU
           DO IV=IV1,IV2,-1
             DATA(IX)=DATA2(IX1)
             IF (IV.GT.IUVI(3) .OR. IV.LT.IUVI(4)) THEN
               IF (IEDGE.EQ.2) DATA(IX)=0.0
             ELSEIF (IV.GT.IUVI(4)) THEN
               IX1=IX1+NX
             ENDIF
             IX=IX+1
           ENDDO
           CALL CNVROW(DATA,NV,NSAMP(2),VBEAM,MAXBV,DATA2(IX2),NY,NX)
         ENDDO
C
         NY=(NY-1)/NX+1
1000     CALL cmd_ERR(STATUS,'SMOOTH',' ')
C
       ENDIF
C
       END
C
C
C+
       SUBROUTINE CNVROW (DATA1, N1, NS1, BEAM, MAXPIX, DATA2, N2, NS2)
C      ----------------------------------------------------------------
C
C  Convolves data array with a symmetric beam.
C
C  Parameters:
C      DATA1     real*4()    input data array
C      N1        integer     input array length
C      NS1       integer     input sampling interval
C      BEAM      real*4()    convolving beam, centre to edge
C      MAXPIX    integer     beam half-width, centre to edge
C      DATA2     real*4()    output data array
C      N2        integer     output array length
C      NS2       integer     output address increment
C
C  Convolves an input data array with a symmetric beam, and produces an
C  output array using sampling interval NS1.  The output array is filled
C  using an address increment NS2, and the final size of the output array
C  is returned in N2.  The symmetric beam is held from centre to edge in
C  a vector of (1+MAXPIX) elements.
C
C-
       REAL*4   DATA1(1), BEAM(1), DATA2(1)
       INTEGER  N1, N2, NS1, NS2, MAXPIX
       INTEGER  I, J, IX2
C
       IX2=1-NS2
       DO I=1+MAXPIX,N1-MAXPIX,NS1
         IX2=IX2+NS2
         DATA2(IX2)=DATA1(I)*BEAM(1)
         DO J=1,MAXPIX
           DATA2(IX2)=DATA2(IX2)+(DATA1(I-J)+DATA1(I+J))*BEAM(J+1)
         ENDDO
       ENDDO
C
       N2=IX2
C
       END

